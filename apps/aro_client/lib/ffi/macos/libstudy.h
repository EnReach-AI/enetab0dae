/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package aro-ext-app/core/pkg/libstudy */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
extern size_t _GoStringLen(_GoString_ s);
extern const char *_GoStringPtr(_GoString_ s);
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 3 "study.go"






#include <stdlib.h>
#include <string.h>

#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef size_t GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
#ifdef _MSC_VER
#if !defined(__cplusplus) || _MSVC_LANG <= 201402L
#include <complex.h>
typedef _Fcomplex GoComplex64;
typedef _Dcomplex GoComplex128;
#else
#include <complex>
typedef std::complex<float> GoComplex64;
typedef std::complex<double> GoComplex128;
#endif
#else
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
#endif

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


// NodeSignUp 节点注册（/api/liteNode/signUp）
// 参数：publicKeyPem - RSA 公钥（PEM 格式）
// 返回：JSON formatted响应（包含用户和节点信息）
//
extern char* NodeSignUp(void);

// NodeReportBaseInfo 上报节点基础信息（/api/liteNode/node/reportBaseInfo）
// 参数：sysInfoJSON - JSON formatted系统信息
// 返回：JSON formatted响应
//
extern char* NodeReportBaseInfo(char* sysInfoJSON);

// GetNodeStat 获取节点统计信息（/api/liteNode/stat）
// 返回：JSON formatted响应（包含用户信息、节点状态、积分等）
//
extern char* GetNodeStat(void);

// GetRewards 获取奖励信息（/api/liteNode/rewards）
// 返回：JSON formatted响应（包含最后网络点数、总奖励、7天数据等）
//
extern char* GetRewards(void);

// GetWSClientStatus 获取 WebSocket 客户端连接状态
// 返回：JSON 格式的响应，包含运行状态
//
extern char* GetWSClientStatus(void);

// StartWSClient 手动启动 WebSocket 客户端
// 返回：JSON 格式的响应，包含启动结果和当前状态
//
extern char* StartWSClient(void);

// InitLibstudy 初始化 libstudy 库
// 加载或创建密钥对、初始化 API 客户端和 WebSocket 客户端
// 参数：initParamsJSON - JSON 格式的初始化参数，包含 ServerConfig
// 返回：JSON formatted响应（包含初始化状态和各个组件的信息）
//
extern char* InitLibstudy(char* initParamsJSON);

// 返回：版本号字符串（C 字符串，调用方需要 free）
//
extern char* GetCurrentVersion(void);
extern char* GetLastVersion(void);

// StartProxyWorker 启动代理工作节点
// 参数：configJSON - JSON 格式的配置字符串，包含以下字段：
//   - sn: 设备序列号
//   - token: 认证 Token
//   - tunnel_id: 隧道 ID
//   - proxy_server_ip: 代理服务器 IP
//   - proxy_server_port: 代理服务器端口
//   - local_port: 本地端口
//   - nat_type: NAT 类型 (0: 动态IP, 1: 静态IP)
//   - fixed_port: 固定端口（仅用于静态 IP）
//   - disable_tls: 是否禁用 TLS（可选，默认 false，即默认使用 wss 加密连接）
//   - tls_secure: 是否验证服务器证书（可选，默认 false，即跳过证书验证）
//   - server_name: TLS ServerName（可选，用于证书验证，为空时使用 proxy_server_ip）
//
// 返回：JSON 格式的响应，包含成功状态和错误信息
//
extern char* StartProxyWorker(char* configJSON);

// StopProxyWorker 停止代理工作节点
// 返回：JSON 格式的响应，包含成功状态和错误信息
//
extern char* StopProxyWorker(void);

// GetProxyWorkerStatus 获取代理工作节点状态
// 返回：JSON 格式的状态信息，包含以下字段：
//   - is_running: 是否正在运行
//   - pid: 进程 ID
//   - local_port: 本地端口
//   - fixed_port: 固定端口（静态IP时使用）
//   - tunnel_id: 隧道 ID
//   - start_time: 启动时间（Unix 时间戳）
//   - error: 错误信息（如果有）
//
extern char* GetProxyWorkerStatus(void);

// RestartProxyWorker 重启代理工作节点
// 使用之前的配置重新启动 worker
// 返回：JSON 格式的响应，包含成功状态和错误信息
//
extern char* RestartProxyWorker(void);

// IsProxyWorkerRunning 检查代理工作节点是否正在运行
// 返回：JSON 格式的响应，包含运行状态
//
extern char* IsProxyWorkerRunning(void);

// Cleanup 清理所有资源，在应用退出前调用
// 停止所有后台任务，关闭连接，释放资源
// 返回：JSON 格式的响应
//
extern char* Cleanup(void);

#ifdef __cplusplus
}
#endif
